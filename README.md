# leetcode刷题记录
14. 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
给定二叉树: [3,9,20,null,null,15,7],返回其层次遍历结果：
[
  [3],
  [20,9],
  [15,7]
]
- 思路：
特例处理： 当树的根节点为空，则直接返回空列表 [] ；
初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；
BFS 循环： 当队列 queue 为空时跳出；
新建一个临时列表 tmp ，用于存储当前层打印结果；
当前层打印循环： 循环次数为队列 queue 长度（队列中元素为所有当前层节点）；
出队： 队首元素出队，记为 node；
打印： 将 node.val 添加至列表 tmp 尾部；
添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；
偶数层倒序： 若 res 的长度为 奇数 ，说明当前是偶数层，则对 tmp 执行 倒序 操作。
将当前层结果 tmp 添加入 res 。
返回值： 返回打印结果列表 res 即可

15. 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
![](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)
16. 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
    - 假设一个二叉搜索树具有如下特征：
    - 节点的左子树只包含小于当前节点的数。
    - 节点的右子树只包含大于当前节点的数。
    - 所有左子树和右子树自身必须也是二叉搜索树。
17. 描述：给定一棵二叉搜索树，请找出其中第k大的节点，1 ≤ k ≤ 二叉搜索树元素个数
18. 给定一个二叉树，找出其最小深度。
19. 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围
20. 给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
21. 在给定的网格中，每个单元格可以有以下三个值之一：
    - 值 0 代表空单元格；
    - 值 1 代表新鲜橘子；
    - 值 2 代表腐烂的橘子。
    - 每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。
    - 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1
22. 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
    - 示例 1：
    - 输入: "babad"
    - 输出: "bab"
    - 注意: "aba" 也是一个有效答案。
    - 示例 2：
    - 输入: "cbbd"
    - 输出: "bb"
 23. 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

        比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，排列如下：
        
        L   C   I   R
        E T O E S I I G
        E   D   H   N
        之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："LCIRETOESIIGEDHN"。
        
        请你实现这个将字符串进行指定行数变换的函数：
        
        string convert(string s, int numRows);
        示例 1:
        
        输入: s = "LEETCODEISHIRING", numRows = 3
        输出: "LCIRETOESIIGEDHN"
        示例 2:
        
        输入: s = "LEETCODEISHIRING", numRows = 4
        输出: "LDREOEIIECIHNTSG"
        解释:
        
        L     D     R
        E   O E   I I
        E C   I H   N
        T     S     G
        
  24. 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

       '.' 匹配任意单个字符
       '*' 匹配零个或多个前面的那一个元素
       所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
       
       说明:
       
       s 可能为空，且只包含从 a-z 的小写字母。
       p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
       示例 1:
       
       输入:
       s = "aa"
       p = "a"
       输出: false
       解释: "a" 无法匹配 "aa" 整个字符串。
       示例 2:
       
       输入:
       s = "aa"
       p = "a*"
       输出: true
       解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
       示例 3:
       
       输入:
       s = "ab"
       p = ".*"
       输出: true
       解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
       示例 4:
       
       输入:
       s = "aab"
       p = "c*a*b"
       输出: true
       解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
       示例 5:
       
       输入:
       s = "mississippi"
       p = "mis*is*p*."
       输出: false
       
    
25. 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内

26.给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

示例：

给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]